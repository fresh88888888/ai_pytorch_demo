
##### Redis架构原理

Redis采用的是C/S架构，其主要组成部分包括：
- 客户端（Client）：项Redis服务器发送命令，获取或存储数据。
- 服务器（Server）：负责处理客户端请求，执行命令，并返回结果。
- 存储引擎（Storage Engine）：Redis主要基于内存存储，并提供RDB和AOF持久化机制。
- 网络处理（Networking）：基于**IO多路复用**技术，实现高并发处理能力。

###### Redis单线程架构

Redis是一个单线程的数据库，即它使用单线程处理所有客户端的请求，Redis使用单线程架构的主要原因如下：
- 内存操作快：Redis主要执行内存操作，避免了磁盘I/O的瓶颈，CPU通常不是性能瓶颈。
- 避免多线程的锁竞争：单线程架构避免了加锁带来的性能开销，提高了执行效率。
- I/O多路复用：Redis采用I/O多路复用技术（如epoll），同时处理多个请求，提高并发性能。
- 事件处理模型：Redis的事件处理模型包括：文件事件（File Event）和时间事件（Time Event）。文件事件：用于处理网络I/O，监听客户端请求，采用Reactor模型的I/O多路复用技术。时间事件：用于执行定时任务，如定期删除过期键、AOF持久化、主从同步检查。通过最小堆维护时间事件，每次循环只检查最早的定时任务，并提高执行效率。

多路复用流程：Redis监听多个客户端的Socket连接，并注册读写事件。当客户端请求到达时，Redis通过epoll或select监听事件。Redis通过事件循环依次处理每个请求（读取数据、执行命令、返回响应）。

Redis单线程的I/O多路复用

Redis在单线程下仍然支持高并发，主要依赖于I/O多路复用，I/O多路复用可以让一个线程同时监听多个I/O事件，避免多个线程同事阻塞等待I/O。epoll：epoll是Linux高效的I/O多路复用方式，比select和poll速度更快，Redis通过epoll同事监听多个Socket连接，在事件发生时一次性处理，避免轮询带来的CPU开销。核心操作流程：
- 实例创建：通过 epoll_create1 创建内核事件表。
- 事件注册：使用 epoll_ctl 注册读/写事件，采用边缘触发模式（ET）
- 事件监听：主线程调用 epoll_wait 获取就绪事件列表
- 数据结构优化：红黑树存储所有监控的 socket fd（插入/删除时间复杂度 O(log n)），就绪链表缓存活跃事件，避免全量遍历（事件检测复杂度 O(1)）。

Redis单线程的优势和劣势：
- 优势：避免了线程切换开销：多线程会有上下文切换，而Redis单线程避免了这个问题。避免锁竞争：多线程需要加锁，而Redis直接是单线程处理，保证了数据的一致性。I/O多路复用：采用epoll，即使单线程也能支持高并发请求。
- 劣势：不能利用多核CPU：Redis只用一个线程处理请求，无法利用多核CPU并行计算。复杂计算任务会阻塞请求：某些命令执行时间过长，会阻塞请求。内存受限：单个Redis进程可能无法管理所有数据，需要分片存储。

Redis单线程优化方案：
- 使用多个Redis实例：在多核CPU机器上运行多个Redis进程，提高吞吐量。
- 使用Redis Cluster集群：Redis Cluster集群采用分片存储，多个节点分担数据，提高性能。
- 避免大数据查询：不要使用 keys *，改用 SCAN进行分批查询，避免阻塞线程。
- 使用Pipline提高吞吐量：Redis支持Pipline批量执行命令，减少网络I/O。

Redis存储原理：Redis主要使用字典(dict)结构存储数据，每个key通过哈希表进行管理：Index= hash(key) mod size。Redis使用渐进式rehash技术优化哈希表扩展过程，以减少一次性rehash造成的性能开销。

Redis的持久化机制：
- RDB（Redis Database）：周期性的将数据快照保存到磁盘，适合备份，但可能会丢失最近的修改。
- AOF（Append Only File）：记录所有写操作，提供更高的数据安全性，但磁盘I/O频率较高。

Redis的高可用架构：
- 主从复制：通过replicaof命令同步数据，实现高可用。
- 哨兵模式：提供故障检测，和自动主从切换，保证系统的稳定性。
- Redis Cluster：采用数据分片技术，实现分布式存储，和高可用架构。

Redis的特点：
- 高性能：Redis基于内存数据库，读写速度极快。
- 持久化：支持RDB（快照）和AOF（日志）两种持久化方式。
- 数据结构丰富：字符串、哈希、列表、集合、有序集合等。
- 原子性操作：Redis提供事务支持，保证数据一致性。
- 分布式支持：通过Redis Cluster进行数据分片，实现高可用和负载均衡。

##### Redis 压缩列表、跳跃表实现原理？

Redis 是一个高性能的键值数据库，它使用了多种数据结构来实现不同的功能。压缩列表（ziplist）和跳跃表（skiplist）是其中两种重要的数据结构。

压缩列表（Ziplist）：压缩列表是一种为节约内存而开发的顺序型数据结构。它被用于列表对象和哈希对象的底层实现。实现思路：
- 连续内存块：压缩列表是一块连续的内存区域，这样可以减少内存碎片。
- 结构：zlbytes：记录整个压缩列表占用的内存字节数。zltail：记录压缩列表表尾节点距离起始地址的偏移量，方便从表尾向表头遍历。zllen：记录压缩列表包含的节点数量。entryX：压缩列表节点，每个节点可以保存一个字节数组或者整数值。zlend：特殊值 0xFF，用于标记压缩列表的末端。
- 节点：每个节点由 previous_entry_length、encoding、content 组成。previous_entry_length 记录了前一个节点的长度，方便从后向前遍历。encoding 记录了当前节点的内容类型和长度。content 是节点的实际数据。
- 优点：节省内存空间。适合存储较小的数据。缺点：由于是连续内存，插入和删除操作可能需要重新分配内存。

跳跃表（Skiplist）

跳跃表是一种有序数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而实现快速访问。Redis 使用跳跃表实现有序集合（Sorted Set）。实现思路：
- 层次结构：跳跃表由多个层组成，每一层都是一个有序的链表。最底层包含所有元素，而上层是对下层的抽样。
- 节点：每个节点包含一个元素和多个指向其他节点的指针。指针的数量由节点的层数决定。
- 查找、插入、删除：查找时，从最高层开始，逐层向下查找，直到找到目标元素或到达最底层。插入和删除操作也是从最高层开始，逐层向下进行。
- 优点：平均时间复杂度为 O(log n)，支持快速的范围查询。实现简单，适合并发环境。
- 缺点：空间复杂度较高，因为每个节点需要维护多个指针。

这两种数据结构在 Redis 中各有用途，压缩列表主要用于节省内存，而跳跃表则用于实现高效的有序集合操作。

